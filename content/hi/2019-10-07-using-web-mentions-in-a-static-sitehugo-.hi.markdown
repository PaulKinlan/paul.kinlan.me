---
slug: using-web-mentions-in-a-static-sitehugo-
date: 2019-10-07T20:11:30.489Z
title: 'Using Web Mentions in a static site (Hugo)'
link: ''
tags: [webmentions, hugo]
---

मेरा ब्लॉग एक पूरी तरह से स्थिर साइट है, जिसे ह्यूगो के साथ बनाया गया है और इसे ज़िट के साथ होस्ट किया गया है। यह मेरे लिए एक महान समाधान है, एक साधारण ब्लॉग में बहुत सरल तैनाती की प्रक्रिया है और यह बहुत तेज़ी से लोड होता है।

सांख्यिकीय रूप से उत्पन्न साइटों में कुछ कमियां होती हैं, सबसे बड़ी तब होती है जब आपको अपने पृष्ठ में एकीकृत होने के लिए गतिशील कुछ भी चाहिए होता है (उदाहरण के लिए टिप्पणियाँ)। गतिशील सामग्री को आसानी से होस्ट करने में सक्षम नहीं होने का मतलब यह होगा कि आप तीसरी पार्टी जावास्क्रिप्ट पर भरोसा करते हैं जो तब आपके पेज पर पूर्ण पहुंच प्राप्त करेगा और आपको नहीं पता होगा कि यह क्या कर रहा है - यह आपके उपयोगकर्ताओं को ट्रैक कर सकता है या आपके पृष्ठ को धीमा कर सकता है। भार।

मैंने हाल ही में अपने वर्तमान टिप्पणी विजेट (Disqus) को महत्वपूर्ण रेंडर पथ से केवल तभी लोड किया जब उपयोगकर्ता टिप्पणियों ( `IntersectionObserver` का उपयोग `IntersectionObserver` ) को स्क्रॉल करता है और जब तक यह लोड प्रदर्शन और ट्रैकिंग समस्याओं का एक उचित समाधान नहीं था, मैं वास्तव में इसे दूर करना चाहता था सभी एक साथ

<a <span class="notranslate">href=&quot;https://webmention.net/draft/&quot; &gt;Webmention</a> कल्पना दर्ज करें। Webmention एक विनिर्देश है जो बताता है कि किसी साइट के लेखक से संपर्क कैसे किया जा सकता है जब आपकी साइट पर किसी अन्य साइट का उल्लेख (या पसंद) हो। यह अंततः आपकी साइट से लिंक करने वाली सामग्री की खोज के लिए एक विकेन्द्रीकृत विधि के लिए अनुमति देता है, उम्मीद है कि मूल्य और अंतर्दृष्टि प्रदान करता है।

वेबमेंशन स्पेक किसी भी डेटा फॉर्मेट का वर्णन नहीं करता है, जिसका उपयोग संचार के लिए किया जाना चाहिए जो कि &#39;उल्लेख साइट&#39; ने कहा है, कि आपको पृष्ठ की सामग्री को समझने के लिए मानक माइक्रोफ़ॉर्मेट्स या अन्य तंत्रों का उपयोग करके पार्स करने के लिए छोड़ दिया गया है। यह बहुत अच्छा है, हालाँकि मेरा मानना है कि यह केंद्रीकृत सेवाओं जैसे कि <a <span class="notranslate">href=&quot;https://webmention.io/&quot; &gt;webmention.io</a> ओर जाता है, जो पृष्ठ से अर्थ निकालने के लिए बहुत आवश्यक बुनियादी सुविधाएं प्रदान करता है।

मुझे Webmention का उपयोग करने का विचार पसंद आया, लेकिन जब किसी को आपकी साइट का उल्लेख करने के लिए (और संभवतः स्टोर) सूचनाएं प्राप्त करने के लिए सर्वर साइड सेटअप की आवश्यकता होती है, तो यह मेरी साइट पर मेरे जैसे स्थैतिक बिल्डर के साथ हमेशा संभव नहीं है। इस पोस्ट के बाकी हिस्सों में जल्दी ही वर्णन किया जाएगा कि मुझे कैसे पसंद आया, उल्लेख और उल्लेख मेरे ज़ोइट ह्यूगो बिल्ड पर होस्ट किए गए रिपॉस्ट।

### एक कदम - एक वेब हब का पता लगाएं

मुझे webmention.io मिला और यह ट्रिक करता है। यह आने वाले पिंगबैक और उल्लेख को संभालता है, यह भी मान्य होगा कि कॉलिंग साइट वास्तव में आपकी सामग्री से लिंक कर रही है और अंत में यह पृष्ठ से डेटा पार्स करेगा ताकि आपको संदर्भ की कुछ समझ हो।

Webmention.io यह पुष्टि करेगा कि आप एक खुली प्रमाणीकरण प्रक्रिया के माध्यम से साइट के मालिक हैं (यह साफ था कि यह rel = मुझे लगता है कि एक प्रदाता को इंगित करता है)

### चरण दो - उन पृष्ठों को बताएं जिन्हें आप उल्लेखों को संभाल सकते हैं

यह दो सरल के रूप में निम्नलिखित `link` को जोड़ने के रूप में सरल है

```html
<link rel="webmention" href="https://webmention.io/paul.kinlan.me/webmention">
<link rel="pingback" href="https://webmention.io/paul.kinlan.me/xmlrpc">
```

### चरण तीन - अपनी साइट में webmention.io एपीआई को एकीकृत करें

यहां आपके पास दो विकल्प हैं, आप अपने पृष्ठ पर एक विजेट जोड़ सकते हैं जो webmention.io एपीआई को कॉल करेगा, या आप अपने निर्माण चरण में webmention.io एपीआई को एकीकृत कर सकते हैं। मैं चाहूंगा कि थ्रीडी पार्टी जेएस की मेजबानी संभव हो, इसलिए मैंने बाद को चुना। मैंने अपनी तैनाती प्रक्रिया के लिए वेबकरणों को एकीकृत किया।

मैं ह्यूगो का उपयोग करता हूं क्योंकि निर्माण तेजी से होता है, और उस के साथ दिमाग में, मुझे यह काम करना था कि कैसे एक इष्टतम तरीके से वेबोइनियन एपीआई को ह्यूगो में एकीकृत किया जाए। कठिन बाधा मेरी साइट पर हर पृष्ठ के लिए एपीआई एंडपॉइंट को नहीं बुलाना था, मेरे पास बहुत सारे पृष्ठ हैं, और अभी तक बहुत सारी टिप्पणियां नहीं हैं।

सौभाग्य से Webmention.io साइट एक आसान समापन बिंदु प्रदान करती है जिससे आप अपने डोमेन के सभी उल्लेख प्राप्त कर सकते हैं। अशुभ बिट यह है कि इस फ़ाइल में आपकी साइट के विरुद्ध किए गए प्रत्येक कार्य के लिए एक प्रविष्टि है।

ह्यूगो में डेटा फ़ाइलों की धारणा भी है जो किसी भी पृष्ठ के लिए सीधे टेम्पलेट में खींची जा सकती है, इसलिए आपको वेबमेंट डेटा फ़ाइल को एक नई संरचना में मैप करना होगा जो ह्यूगो टेम्पलेट के अंदर पढ़ना आसान बनाता है।

मेरे द्वारा चुनी गई प्रक्रिया नीचे है, लेकिन सारांश यह है कि मैं क्रियाओं की सूची से सरणी को URL के एक शब्दकोश में बदल देता हूं जिसमें प्रत्येक में एपीआई (जैसे, रिपॉस्ट और रिप्लाई) द्वारा उजागर की गई क्रियाएं होती हैं, और अंतिम चरण तब होता है URL के शब्दकोश को अलग-अलग फ़ाइलों में विभाजित करें जिन्हें url के md5 हैश के रूप में नामित किया गया है।

```javascript
"use strict";

const fs = require('fs');
const fetch = require('node-fetch');
const md5 = require('md5');

const processMentionsJson = (data) => {
  const urlData = {};
  data.children.forEach(item => {
    const wmProperty = item["wm-property"];
    const url = item[wmProperty];

    if(url in urlData === false) urlData[url] = {};
    const urlDataItem = urlData[url];

    if(wmProperty in urlDataItem === false) urlDataItem[wmProperty] = [];
    urlDataItem[wmProperty].push(item);
  });

  console.log(urlData);

  // For each URL in the blog we now have a JSON stucture that has all the like, mentions and reposts
  if(fs.existsSync('./data') === false) fs.mkdirSync('./data');
  Object.keys(urlData).forEach(key => {
    const item = urlData[key];
    const md5url = md5(key);
    console.log(key, md5url)
    fs.writeFileSync(`./data/${md5url}.json`, JSON.stringify(item));
  });
}

(async () => {
  const mentionsUrl = new URL(process.argv[2]); // Fail hard if it's not a uRL

  const mentionsResponse = await fetch(mentionsUrl);
  const mentiosnJson = await mentionsResponse.json();

  processMentionsJson(mentiosnJson);
})();
```

एक बार डेटा को पार्स और सही तरीके से सहेजे जाने के बाद, यह टेम्प्लेट को स्थापित करने की एक त्वरित प्रक्रिया है ताकि इसे टेम्प्लेट के डेटा विशेषता में पढ़ा जा सके।

```html
{{ $urlized := .Page.Permalink | md5 }}
{{ if index .Site.Data $urlized }}
  {{ $likes := index (index .Site.Data $urlized) "like-of" }}
  {{ $replys := index (index .Site.Data $urlized) "in-reply-to" }}
  {{ $reposts := index (index .Site.Data $urlized) "repost-of"}}
  <h4>Likes</h4>
  {{ range $i, $like := $likes }}
    <a href="{{$like.url}}"><img src="{{ $like.author.photo}}" alt="{{ $like.author.name }}" class="profile photo"></a>
  {{end}}

  <h4>Reposts</h4>
  {{ range $i, $repost := $reposts }}
    <a href="{{$repost.url}}"><img src="{{ $repost.author.photo}}" alt="{{ $repost.author.name }}" class="profile photo"></a>
  {{end}}

  <h4>Comments and Replies</h4>
  {{ range $i, $reply := $replys }}
    <a href="{{$reply.url}}"><img src="{{ $reply.author.photo}}" alt="{{ $reply.author.name }}" class="profile photo"></a>
  {{end}}
{{end}}
```

यदि सब कुछ ठीक हो जाता है, तो आपको पृष्ठ के निचले भाग में कुछ आइकन देखने चाहिए जो वास्तविक लोग साइट के साथ इंटरैक्ट कर रहे हैं।

### चरण 4 - टिप्पणी होने पर साइट प्रकाशित करें

जब भी उपरोक्त कदम मुझे उल्लेखों को एकत्र करने और उन्हें साइट आउटपुट में प्रस्तुत करने देंगे, मुझे अभी भी यह सुनिश्चित करना है कि साइट को नियमित रूप से फिर से बनाया जाए ताकि टिप्पणियां सार्वजनिक रूप से दिखाई दें।

मैंने एक साधारण क्रोन सेवा का उपयोग करने के लिए चुना है जो हर घंटे या तो साइट पर फिर से तैनात करने के लिए ज़ाइट की तैनाती एपीआई को कॉल करेगा।
