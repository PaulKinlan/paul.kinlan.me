---
slug: using-web-mentions-in-a-static-sitehugo-
date: 2019-10-07T20:11:30.489Z
title: 'Using Web Mentions in a static site (Hugo)'
link: ''
tags: [webmentions, hugo]
---

నా బ్లాగ్ పూర్తిగా స్టాటిక్ సైట్, ఇది హ్యూగోతో నిర్మించబడింది మరియు జైట్ తో హోస్ట్ చేయబడింది. ఇది నాకు గొప్ప పరిష్కారం, ఒక సాధారణ బ్లాగులో చాలా సరళమైన విస్తరణ ప్రక్రియ ఉంది మరియు ఇది వేగంగా వేగంగా లోడ్ అవుతుంది.

గణాంకపరంగా ఉత్పత్తి చేయబడిన సైట్‌లకు కొన్ని లోపాలు ఉన్నాయి, మీ పేజీలో విలీనం కావడానికి డైనమిక్ ఏదైనా మీకు అవసరమైనప్పుడు పెద్దది (ఉదాహరణకు వ్యాఖ్యలు). డైనమిక్ కంటెంట్‌ను సులభంగా హోస్ట్ చేయలేకపోవడం అంటే మీరు 3 వ పార్టీ జావాస్క్రిప్ట్‌పై ఆధారపడటం అంటే మీ పేజీకి పూర్తి ప్రాప్యత లభిస్తుంది మరియు అది ఏమి చేస్తుందో మీకు తెలియదు - ఇది మీ వినియోగదారులను ట్రాక్ చేయడం లేదా మీ పేజీని మందగించడం లోడ్.

నేను ఇటీవల నా ప్రస్తుత వ్యాఖ్య విడ్జెట్ ( `IntersectionObserver` ) ను క్లిష్టమైన రెండర్ మార్గంలో నుండి `IntersectionObserver` , వినియోగదారు వ్యాఖ్యలకు స్క్రోల్ చేసినప్పుడు మాత్రమే ( `IntersectionObserver` ఉపయోగించి) మరియు లోడ్ పనితీరు మరియు ట్రాకింగ్ సమస్యలకు ఇది సహేతుకమైన పరిష్కారం అయితే, నేను నిజంగా తొలగించాలనుకుంటున్నాను అన్నీ కలిసి డిస్కస్.

<a <span class="notranslate">href=&quot;https://webmention.net/draft/&quot; &gt;Webmention</a> స్పెక్‌ను నమోదు చేయండి. వెబ్‌మెన్షన్ అనేది మీ సైట్‌లోని మరొక సైట్ &#39;ప్రస్తావించినప్పుడు&#39; (లేదా ఇష్టపడినప్పుడు) సైట్ రచయితను ఎలా సంప్రదించవచ్చో వివరించే ఒక వివరణ. ఇది చివరికి మీ సైట్‌కు లింక్ చేసే కంటెంట్‌ను కనుగొనటానికి వికేంద్రీకృత పద్ధతిని అనుమతిస్తుంది, ఆశాజనక విలువ మరియు అంతర్దృష్టిని అందిస్తుంది.

వెబ్‌మెన్షన్ స్పెక్ &#39;ప్రస్తావించే సైట్&#39; చెప్పినదానిని కమ్యూనికేట్ చేయడానికి ఉపయోగించాల్సిన డేటా ఫార్మాట్‌లను వివరించలేదు, ఇది పేజీ యొక్క కంటెంట్‌ను అర్థం చేసుకోవడానికి ప్రామాణిక మైక్రోఫార్మాట్‌లు లేదా ఇతర యంత్రాంగాలను ఉపయోగించి అన్వయించడానికి మిమ్మల్ని వదిలివేస్తుంది. ఇది చాలా బాగుంది, అయితే ఇది <a <span class="notranslate">href=&quot;https://webmention.io/&quot; &gt;webmention.io</a> వంటి కేంద్రీకృత సేవలకు దారితీస్తుందని నేను నమ్ముతున్నాను.

వెబ్‌మెన్షన్‌ను ఉపయోగించాలనే ఆలోచన నాకు నచ్చింది, కానీ మీ సైట్‌ను ఎవరైనా ప్రస్తావించినప్పుడు నోటిఫికేషన్‌లను పొందడానికి (మరియు బహుశా స్టోర్) సర్వర్ సైడ్ సెటప్ అవసరం, నా సైట్‌లో ఉన్నట్లుగా స్టాటిక్ బిల్డర్‌తో ఇది ఎల్లప్పుడూ సాధ్యం కాదు. ఈ పోస్ట్ యొక్క మిగిలినవి నా జైట్ హోస్ట్ చేసిన హ్యూగో బిల్డ్‌లో హోస్ట్ చేసిన లైక్‌లు, ప్రస్తావనలు మరియు రిపోస్ట్‌లు ఎలా వచ్చాయో త్వరగా వివరిస్తాయి.

### దశ ఒకటి - వెబ్‌మెన్షన్ హబ్‌ను కనుగొనండి

నేను webmention.io ని కనుగొన్నాను మరియు అది ట్రిక్ చేస్తుంది. ఇది ఇన్‌కమింగ్ పింగ్‌బ్యాక్‌లను నిర్వహిస్తుంది మరియు ప్రస్తావించింది, కాలింగ్ సైట్ వాస్తవానికి మీ కంటెంట్‌తో లింక్ అవుతోందని కూడా ధృవీకరిస్తుంది మరియు చివరకు ఇది పేజీ నుండి డేటాను అన్వయిస్తుంది, తద్వారా మీకు సందర్భం గురించి కొంత అవగాహన ఉంటుంది.

ఓపెన్ ప్రామాణీకరణ ప్రక్రియ ద్వారా మీరు సైట్‌ను కలిగి ఉన్నారని Webmention.io ధృవీకరిస్తుంది (ఇది ప్రామాణికమైన ప్రొవైడర్‌ను సూచించే rel = me కోసం చూస్తుంది)

### దశ రెండు - మీరు ప్రస్తావించగలిగే పేజీలను చెప్పండి

ఈ క్రింది రెండు `link` ట్యాగ్‌లను జోడించినంత సులభం

```html
<link rel="webmention" href="https://webmention.io/paul.kinlan.me/webmention">
<link rel="pingback" href="https://webmention.io/paul.kinlan.me/xmlrpc">
```

### దశ మూడు - webmention.io API ని మీ సైట్‌లోకి అనుసంధానించండి

మీకు ఇక్కడ రెండు ఎంపికలు ఉన్నాయి, మీరు మీ పేజీకి webmention.io API అని పిలిచే ఒక విడ్జెట్‌ను జోడించవచ్చు లేదా మీరు మీ నిర్మాణ దశలో webmention.io API ని ఏకీకృతం చేయవచ్చు. నేను వీలైనంత తక్కువ 3 వ పార్టీ JS ను హోస్ట్ చేయాలనుకుంటున్నాను, కాబట్టి నేను రెండోదాన్ని ఎంచుకున్నాను. నేను నా విస్తరణ ప్రక్రియలో వెబ్‌మెంటేషన్లను అనుసంధానించాను.

నేను హ్యూగోను ఉపయోగిస్తున్నాను ఎందుకంటే బిల్డ్ వేగంగా ఉంది, మరియు దానిని దృష్టిలో ఉంచుకుని, వెబ్‌మెన్షన్ API ని హ్యూగోలోకి ఎలా సమగ్రంగా సమగ్రపరచాలో నేను పని చేయాల్సి వచ్చింది. నా సైట్‌లోని ప్రతి పేజీకి API ఎండ్‌పాయింట్‌ను పిలవకపోవడం చాలా కష్టం, నాకు చాలా పేజీలు ఉన్నాయి మరియు ఇంకా చాలా వ్యాఖ్యలు లేవు.

అదృష్టవశాత్తూ Webmention.io సైట్ మీ డొమైన్ కోసం ప్రస్తావించిన అన్నిటినీ స్వీకరించడానికి మిమ్మల్ని అనుమతిస్తుంది. దురదృష్టకరమైన బిట్ ఏమిటంటే, ఈ ఫైల్ మీ సైట్‌కు వ్యతిరేకంగా చేసిన ప్రతి చర్యకు ఒక ఎంట్రీని కలిగి ఉంటుంది.

ఏదైనా పేజీకి నేరుగా మూసలోకి లాగగల డేటా ఫైళ్ళ భావనను హ్యూగో కలిగి ఉంది, కాబట్టి మీరు వెబ్‌మెన్షన్ డేటా ఫైల్‌ను కొత్త నిర్మాణానికి మ్యాప్ చేయాలి, అది హ్యూగో టెంప్లేట్ లోపల చదవడం సులభం చేస్తుంది.

నేను ఎంచుకున్న ప్రక్రియ క్రింద ఉంది, కానీ సారాంశం ఏమిటంటే నేను చర్యల జాబితా నుండి URL యొక్క నిఘంటువుకు మారుస్తాను, వీటిలో ప్రతి ఒక్కటి API ద్వారా బహిర్గతం చేయబడిన చర్యలను కలిగి ఉంటాయి (వంటివి, రీపోస్ట్ మరియు ప్రత్యుత్తరం వంటివి), మరియు చివరి దశ అప్పుడు URL ల యొక్క నిఘంటువును వ్యక్తిగత ఫైళ్ళగా విభజించండి, అవి url యొక్క md5 హాష్ అని పేరు పెట్టబడ్డాయి.

```javascript
"use strict";

const fs = require('fs');
const fetch = require('node-fetch');
const md5 = require('md5');

const processMentionsJson = (data) => {
  const urlData = {};
  data.children.forEach(item => {
    const wmProperty = item["wm-property"];
    const url = item[wmProperty];

    if(url in urlData === false) urlData[url] = {};
    const urlDataItem = urlData[url];

    if(wmProperty in urlDataItem === false) urlDataItem[wmProperty] = [];
    urlDataItem[wmProperty].push(item);
  });

  console.log(urlData);

  // For each URL in the blog we now have a JSON stucture that has all the like, mentions and reposts
  if(fs.existsSync('./data') === false) fs.mkdirSync('./data');
  Object.keys(urlData).forEach(key => {
    const item = urlData[key];
    const md5url = md5(key);
    console.log(key, md5url)
    fs.writeFileSync(`./data/${md5url}.json`, JSON.stringify(item));
  });
}

(async () => {
  const mentionsUrl = new URL(process.argv[2]); // Fail hard if it's not a uRL

  const mentionsResponse = await fetch(mentionsUrl);
  const mentiosnJson = await mentionsResponse.json();

  processMentionsJson(mentiosnJson);
})();
```

డేటాను అన్వయించి, సరిగ్గా సేవ్ చేసిన తర్వాత, ఇది టెంప్లేట్‌ను సెటప్ చేసే శీఘ్ర ప్రక్రియ, తద్వారా ఇది టెంప్లేట్ యొక్క డేటా లక్షణంలో చదవబడుతుంది.

```html
{{ $urlized := .Page.Permalink | md5 }}
{{ if index .Site.Data $urlized }}
  {{ $likes := index (index .Site.Data $urlized) "like-of" }}
  {{ $replys := index (index .Site.Data $urlized) "in-reply-to" }}
  {{ $reposts := index (index .Site.Data $urlized) "repost-of"}}
  <h4>Likes</h4>
  {{ range $i, $like := $likes }}
    <a href="{{$like.url}}"><img src="{{ $like.author.photo}}" alt="{{ $like.author.name }}" class="profile photo"></a>
  {{end}}

  <h4>Reposts</h4>
  {{ range $i, $repost := $reposts }}
    <a href="{{$repost.url}}"><img src="{{ $repost.author.photo}}" alt="{{ $repost.author.name }}" class="profile photo"></a>
  {{end}}

  <h4>Comments and Replies</h4>
  {{ range $i, $reply := $replys }}
    <a href="{{$reply.url}}"><img src="{{ $reply.author.photo}}" alt="{{ $reply.author.name }}" class="profile photo"></a>
  {{end}}
{{end}}
```

అన్నీ సరిగ్గా జరిగితే, మీరు సైట్‌తో సంభాషించే నిజమైన వ్యక్తులు పేజీ దిగువన కొన్ని చిహ్నాలను చూడాలి.

### దశ 4 - వ్యాఖ్యలు జరిగినప్పుడు సైట్‌ను ప్రచురించండి

పై దశలు నన్ను ప్రస్తావించి, సైట్‌ల అవుట్‌పుట్‌లో అందించడానికి వీలు కల్పిస్తాయి, అయితే, వ్యాఖ్యలు బహిరంగంగా కనిపించే విధంగా సైట్ క్రమం తప్పకుండా పునర్నిర్మించబడిందని నేను నిర్ధారించుకోవాలి.

నేను ఒక సాధారణ క్రాన్ సేవను ఉపయోగించాలని ఎంచుకున్నాను, అది ప్రతి గంటకు లేదా అంతకుముందు సైట్ యొక్క తిరిగి డిపోలీని బలవంతం చేయడానికి జైట్ యొక్క విస్తరణ API ని పిలుస్తుంది.
